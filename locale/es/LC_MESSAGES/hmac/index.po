#
msgid ""
msgstr ""
"Project-Id-Version: Python Module of the Week 2.1.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-10-06 13:35-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../PyMOTW/hmac/index.rst:3
msgid "hmac -- Cryptographic signature and verification of messages."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:9
msgid ""
"The hmac module implements keyed-hashing for message authentication, as "
"described in :rfc:`2104`."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:11
msgid "2.2"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:13
msgid ""
"The HMAC algorithm can be used to verify the integrity of information passed"
" between applications or stored in a potentially vulnerable location. The "
"basic idea is to generate a cryptographic hash of the actual data combined "
"with a shared secret key. The resulting hash can then be used to check the "
"transmitted or stored message to determine a level of trust, without "
"transmitting the secret key."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:20
msgid ""
"Disclaimer: I'm not a security expert. For the full details on HMAC, check "
"out :rfc:`2104`."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:24
msgid "Example"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:26
msgid ""
"Creating the hash is not complex. Here's a simple example which uses the "
"default MD5 hash algorithm:"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:33
msgid ""
"When run, the code reads its source file and computes an HMAC signature for "
"it:"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:50
msgid ""
"If I haven't changed the file by the time I release the example source for "
"this week, the copy you download should produce the same hash."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:55
msgid "SHA vs. MD5"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:57
msgid ""
"Although the default cryptographic algorithm for :mod:`hmac` is MD5, that is"
" not the most secure method to use. MD5 hashes have some weaknesses, such as"
" collisions (where two different messages produce the same hash). The SHA-1 "
"algorithm is considered to be stronger, and should be used instead."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:67
msgid ""
"``hmac.new()`` takes 3 arguments. The first is the secret key, which should "
"be shared between the two endpoints which are communicating so both ends can"
" use the same value. The second value is an initial message. If the message "
"content that needs to be authenticated is small, such as a timestamp or HTTP"
" POST, the entire body of the message can be passed to ``new()`` instead of "
"using the update() method. The last argument is the digest module to be "
"used. The default is ``hashlib.md5``. The previous example substitutes "
"``hashlib.sha1``."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:89
msgid "Binary Digests"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:91
msgid ""
"The first few examples used the ``hexdigest()`` method to produce printable "
"digests. The hexdigest is is a different representation of the value "
"calculated by the ``digest()`` method, which is a binary value that may "
"include unprintable or non-ASCII characters, including NULs. Some web "
"services (Google checkout, Amazon S3) use the ``base64`` encoded version of "
"the binary digest instead of the hexdigest."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:103
msgid ""
"The base64 encoded string ends in a newline, which frequently needs to be "
"stripped off when embedding the string in HTTP headers or other formatting-"
"sensitive contexts."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:122
msgid "Applications"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:124
msgid ""
"HMAC authentication should be used for any public network service, and any "
"time data is stored where security is important. For example, when sending "
"data through a pipe or socket, that data should be signed and then the "
"signature should be tested before the data is used. The extended example "
"below is available in the ``hmac_pickle.py`` file as part of the PyMOTW "
"source package."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:131
msgid ""
"First, let's establish a function to calculate a digest for a string, and a "
"simple class to be instantiated and passed through a communication channel."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:159
msgid ""
"Next, create a :mod:`StringIO` buffer to represent the socket or pipe. We "
"will using a naive, but easy to parse, format for the data stream. The "
"digest and length of the data are written, followed by a new line. The "
"serialized representation of the object, generated by :mod:`pickle`, "
"follows. In a real system, we would not want to depend on a length value, "
"since if the digest is wrong the length is probably wrong as well. Some sort"
" of terminator sequence not likely to appear in the real data would be more "
"appropriate."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:168
msgid ""
"For this example, we will write two objects to the stream. The first is "
"written using the correct digest value."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:186
msgid ""
"The second object is written to the stream with an invalid digest, produced "
"by calculating the digest for some other data instead of the pickle."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:203
msgid ""
"Now that the data is in the :mod:`StringIO` buffer, we can read it back out "
"again.  The first step is to read the line of data with the digest and data "
"length.  Then the remaining data is read (using the length value). We could "
"use ``pickle.load()`` to read directly from the stream, but that assumes a "
"trusted data stream and we do not yet trust the data enough to unpickle it. "
"Reading the pickle as a string collect the data from the stream, without "
"actually unpickling the object."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:227
msgid ""
"Once we have the pickled data, we can recalculate the digest value and "
"compare it against what we read. If the digests match, we know it is safe to"
" trust the data and unpickle it."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:242
msgid ""
"The output shows that the first object is verified and the second is deemed "
"\"corrupted\", as expected:"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:271
msgid "`hmac <http://docs.python.org/library/hmac.html>`_"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:271
msgid "The standard library documentation for this module."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:274
msgid ":rfc:`2104`"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:274
msgid "HMAC: Keyed-Hashing for Message Authentication"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:277
msgid ":mod:`hashlib`"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:277
msgid "The :mod:`hashlib` module."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:280
msgid ":mod:`pickle`"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:280
msgid "Serialization library."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:283
msgid "`WikiPedia: MD5 <http://en.wikipedia.org/wiki/MD5>`_"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:283
msgid "Description of the MD5 hashing algorithm."
msgstr ""

#: ../../PyMOTW/hmac/index.rst:285
msgid ""
"`Authenticating to Amazon S3 Web Service "
"<http://docs.amazonwebservices.com/AmazonS3/2006-03-01/index.html?S3_Authentication.html>`_"
msgstr ""

#: ../../PyMOTW/hmac/index.rst:286
msgid ""
"Instructions for authenticating to S3 using HMAC-SHA1 signed credentials."
msgstr ""
